Other than the default mem table implementation using skip lists, users can use another type of mem table implementation, HashLinkList or HashSkipList, to speed-up some queries.

As what their names show, mem table using HashLinkList organizes data in an open hash table with each hash bucket to be a skip list, while the HashSkipList one organizes data in a hash table with each hash bucket as a single linked list. Both types are built to reduce number of comparisons when doing queries. One target setting is to use it with PlainTable SST format and store data in RAMFS.

When doing a look-up or inserting a key, target key's prefix is retrieved using Options.prefix_extractor, which is used to find the hash bucket. Inside a hash bucket, all the comparisions are done using whole (internal) keys, just as SkipList based mem table.

Comparison:

{| class="wikitable"
|-
! Mem Table Type
! SkipList
! HashSkipList
! HashLinkList
|-
! Optimized Use Case
| General
| Prefix-based iterating
| Prefix-based iterating and there are only small number of rows for each prefix
|-
! Get() or Find Position to Insert in Put()
| binary search
| hash + binary search
| hash + linear search
|-
! Non-prefix Seek() before iterating
| binary
| extremely costly
| extremely costly
|-
! Prefix Seek() before iterating
| binary search
| hash + binary search
| hash + linear search
|-
! Memory Usage
| Average (data + pointers in list entries)
| Lower (Data + Hash Buckets + Skip List Metadata for non-empty buckets + skip list pointers)
| Higher (Hash buckets + pointer for linked list entries)
|-
! Mem Table Flush
| Fast with constant extra memory
| Slow with high memory usage (Sort all the entries into another list first)
| Slow with high memory usage (Sort all the entries into another list first)
|}

The biggest limitation of the hash based mem tables is that doing general iterating requires a pre-sorting, which is very slow and memory consumption.