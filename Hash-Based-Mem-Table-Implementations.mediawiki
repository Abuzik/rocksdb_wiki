Other than the default mem table implementation using skip lists, users can use other types of mem table implementation, for example HashLinkList and HashSkipList, to speed-up some queries.

As their names imply, HashSkipList organizes data in a hash table with each hash bucket to be a skip list, while HashLinkList organizes data in a hash table with each hash bucket as a sorted single linked list. Both types are built to reduce number of comparisons when doing queries. One good use case is to combine them with PlainTable SST format and store data in RAMFS.

When doing a look-up or inserting a key, target key's prefix is retrieved using Options.prefix_extractor, which is used to find the hash bucket. Inside a hash bucket, all the comparisons are done using whole (internal) keys, just as SkipList based mem table.

Comparison:

{| class="wikitable"
|-
! Mem Table Type
! SkipList
! HashSkipList
! HashLinkList
|-
! Optimized Use Case
| General
| Range query within a specific key prefix
| Range query within a specific key prefix and there are only a small number of rows for each prefix
|-
! Index type
| binary search
| hash + binary search
| hash + linear search
|-
! Prefix Seek() before iterating
| binary search
| hash + binary search
| hash + linear search
|-
! Non-prefix Seek() before iterating
| binary
| extremely costly
| extremely costly
|-
! Memory Usage
| Average (data + pointers in list entries)
| Lower (Data + Hash Buckets + Skip List Metadata for non-empty buckets + skip list pointers)
| Higher (Hash buckets + pointer for linked list entries)
|-
! Mem Table Flush
| Fast with constant extra memory
| Slow with high memory usage (Sort all the entries into another list first)
| Slow with high memory usage (Sort all the entries into another list first)
|}

The biggest limitation of the hash based mem tables is that doing general iterating requires a pre-sorting, which is very slow and memory consumption.
